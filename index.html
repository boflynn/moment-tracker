<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moment Tracker</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles can go here if needed, but Tailwind is preferred */
        body {
            font-family: 'Inter', sans-serif;
            /* Using Inter font as per instructions */
            background-color: #f3f4f6;
            /* Light gray background */
        }

        .countdown-card {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s ease-in-out;
        }

        .countdown-card:hover {
            transform: translateY(-5px);
        }

        /* Style for stopped events */
        .stopped-event {
            background-color: #f0f4f8;
            /* Lighter background for stopped events */
            border-color: #cbd5e0;
            /* Grayer border for stopped events */
        }

        .stopped-text {
            color: #64748b;
            /* Gray text for stopped time */
        }
    </style>
</head>

<body class="bg-gray-100 min-h-screen flex flex-col items-center py-8 px-4 sm:px-6 lg:px-8">
    <div class="max-w-4xl w-full bg-white p-6 sm:p-8 rounded-lg shadow-xl border border-gray-200">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-center text-gray-900 mb-8 leading-tight">
            Moment Tracker
        </h1>

        <!-- Add New Countdown Section -->
        <div class="mb-10 p-6 bg-blue-50 rounded-lg border border-blue-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-5 text-center">Add a New Moment</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div class="md:col-span-1">
                    <label for="description" class="block text-sm font-medium text-gray-700 mb-1">Description</label>
                    <input type="text" id="description" placeholder="e.g., Christmas, Vacation, Project Deadline"
                        class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm transition duration-150 ease-in-out" />
                </div>
                <div class="md:col-span-1">
                    <label for="targetDate" class="block text-sm font-medium text-gray-700 mb-1">Target Date</label>
                    <!-- Input type changed to 'date' for selecting only date -->
                    <input type="date" id="targetDate"
                        class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm transition duration-150 ease-in-out" />
                </div>
                <div class="md:col-span-1 flex items-end">
                    <button id="addCountdown"
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-150 ease-in-out transform hover:scale-105">
                        Add Countdown
                    </button>
                </div>
            </div>
            <p id="errorMessage" class="text-red-600 text-sm mt-2 hidden text-center"></p>
        </div>

        <!-- Countdown List Section -->
        <div id="countdownsContainer" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- Countdown cards will be rendered here by JavaScript -->
            <p id="noCountdownsMessage" class="col-span-full text-center text-gray-500 text-lg hidden">
                No countdowns added yet. Add one above!
            </p>
        </div>
    </div>

    <script>
        // Set a default font family for the entire document as recommended.
        document.documentElement.style.fontFamily = "'Inter', sans-serif";

        // Array to store countdown objects
        let countdowns = [];
        // Object to store intervals, so we can clear them when a countdown is removed or stopped
        const countdownIntervals = {};

        // Get DOM elements
        const descriptionInput = document.getElementById('description');
        const targetDateInput = document.getElementById('targetDate');
        const addCountdownButton = document.getElementById('addCountdown');
        const countdownsContainer = document.getElementById('countdownsContainer');
        const errorMessage = document.getElementById('errorMessage');
        const noCountdownsMessage = document.getElementById('noCountdownsMessage');

        /**
         * Encodes the countdowns array into a URL-friendly Base64 string.
         * The process is: JSON.stringify -> btoa (Base64) -> encodeURIComponent.
         * @param {Array<Object>} data The array of countdown objects.
         * @returns {string} The encoded string.
         */
        function encodeCountdowns(data) {
            try {
                const jsonString = JSON.stringify(data);
                const base64String = btoa(jsonString); // Encode to Base64
                return encodeURIComponent(base64String); // Encode for URL safety
            } catch (e) {
                console.error("Error encoding countdowns:", e);
                return '';
            }
        }

        /**
         * Decodes the URL-friendly Base64 string back into the countdowns array.
         * The process is: decodeURIComponent -> atob (Base64 decode) -> JSON.parse.
         * @param {string} encodedString The encoded string from the URL.
         * @returns {Array<Object>} The decoded array of countdown objects, or an empty array on error.
         */
        function decodeCountdowns(encodedString) {
            try {
                const decodedUriComponent = decodeURIComponent(encodedString); // Decode URL component
                const decodedBase64 = atob(decodedUriComponent); // Decode from Base64
                return JSON.parse(decodedBase64); // Parse JSON string
            } catch (e) {
                console.error("Error decoding countdowns:", e);
                return []; // Return empty array on error
            }
        }

        // Function to update the URL with the current countdowns data
        function updateUrl() {
            const encodedData = encodeCountdowns(countdowns);
            // Use replaceState to avoid adding multiple history entries for small changes
            window.history.replaceState(null, '', `?data=${encodedData}`);
        }

        /**
         * Calculates and formats the time remaining until or since the target date.
         * Displays as "Xd Yh Zm As" or "Xd Yh Zm As ago" or "Xd Yh Zm As (stopped)".
         * @param {string} targetDate The target date string (ISO format).
         * @param {string | null} stoppedAt The ISO string timestamp when the event was stopped, or null.
         * @returns {string} The formatted time string.
         */
        function getTimeRemaining(targetDate, stoppedAt) {
            const targetTime = new Date(targetDate).getTime();
            let distance;
            let suffix = '';
            let isPast = false;

            if (stoppedAt) {
                // If stopped, calculate distance from targetDate to stoppedAt
                distance = new Date(stoppedAt).getTime() - targetTime;
                suffix = ' (stopped)';
                isPast = true; // A stopped event will always be considered 'past' for calculation purposes here
            } else {
                // If not stopped, calculate distance from targetDate to now
                const now = new Date().getTime();
                distance = targetTime - now;

                if (distance < 0) {
                    suffix = ' ago'; // Add 'ago' for past dates
                    distance = Math.abs(distance); // Use absolute distance for calculations
                    isPast = true;
                } else if (distance === 0) {
                    return "Just now!";
                }
            }

            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);

            // Build the string dynamically, omitting parts that are zero if larger units are zero
            let timeString = '';
            if (days > 0) timeString += `${days}d `;
            if (days > 0 || hours > 0) timeString += `${hours}h `;
            if (days > 0 || hours > 0 || minutes > 0) timeString += `${minutes}m `;
            timeString += `${seconds}s`; // Seconds always shown

            return timeString.trim() + suffix; // Add suffix at the end
        }

        // Function to render a single countdown card
        function renderCountdownCard(countdown, index) {
            const card = document.createElement('div');
            card.id = `countdown-${index}`; // Assign a unique ID for updates
            card.className = `countdown-card bg-white p-5 rounded-lg border border-gray-200 flex flex-col justify-between ${countdown.stoppedAt ? 'stopped-event' : ''}`;

            const descriptionElem = document.createElement('h3');
            descriptionElem.className = 'text-xl font-semibold text-gray-800 mb-3';
            descriptionElem.textContent = countdown.description;

            const dateElem = document.createElement('p');
            dateElem.className = 'text-sm text-gray-500 mb-4';
            // Changed to toLocaleDateString() to exclude the time part
            dateElem.textContent = `Target: ${new Date(countdown.targetDate).toLocaleDateString()}`;

            const timeRemainingElem = document.createElement('p');
            timeRemainingElem.className = `text-3xl font-bold ${countdown.stoppedAt ? 'text-gray-500 stopped-text' : 'text-blue-600'} mb-4`;

            const actionsContainer = document.createElement('div');
            actionsContainer.className = 'flex justify-end space-x-2 mt-auto'; // Flex container for buttons

            // Remove Button (always present)
            const removeButton = document.createElement('button');
            removeButton.className = 'bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out';
            removeButton.textContent = 'Remove';
            removeButton.onclick = () => removeCountdown(index);
            actionsContainer.appendChild(removeButton);

            // Stop Button (conditionally present)
            const targetTime = new Date(countdown.targetDate).getTime();
            const now = new Date().getTime();

            // Only show stop button if event is in the past AND not already stopped
            if (!countdown.stoppedAt && targetTime < now) {
                const stopButton = document.createElement('button');
                stopButton.className = 'bg-yellow-500 hover:bg-yellow-600 text-white font-medium py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out';
                stopButton.textContent = 'Stop Tracking';
                stopButton.onclick = () => stopCountdown(index);
                actionsContainer.appendChild(stopButton);
            }

            card.append(descriptionElem, dateElem, timeRemainingElem, actionsContainer);
            countdownsContainer.appendChild(card);

            // Clear any existing interval for this card before setting a new one
            if (countdownIntervals[index]) {
                clearInterval(countdownIntervals[index]);
            }

            // Update time remaining only if the event is not stopped
            if (!countdown.stoppedAt) {
                const updateTime = () => {
                    const timeStr = getTimeRemaining(countdown.targetDate, countdown.stoppedAt);
                    timeRemainingElem.textContent = timeStr;

                    // Dynamically change text color based on past/future
                    if (new Date(countdown.targetDate).getTime() < now) { // Check if the *original* event time is in the past
                        timeRemainingElem.classList.remove('text-blue-600');
                        timeRemainingElem.classList.add('text-gray-500'); // Gray for past events
                    } else {
                        timeRemainingElem.classList.remove('text-gray-500');
                        timeRemainingElem.classList.add('text-blue-600'); // Blue for future events
                    }

                    // If event has passed and is not stopped, ensure the stop button is visible.
                    // This handles cases where a future event passes while the app is open.
                    if (!countdown.stoppedAt && new Date(countdown.targetDate).getTime() < now) {
                        if (!actionsContainer.querySelector('.bg-yellow-500')) { // Check if button is already there
                            const stopButton = document.createElement('button');
                            stopButton.className = 'bg-yellow-500 hover:bg-yellow-600 text-white font-medium py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out';
                            stopButton.textContent = 'Stop Tracking';
                            stopButton.onclick = () => stopCountdown(index);
                            // Insert before remove button if remove button exists, otherwise append
                            const existingRemoveButton = actionsContainer.querySelector('.bg-red-500');
                            if (existingRemoveButton) {
                                actionsContainer.insertBefore(stopButton, existingRemoveButton);
                            } else {
                                actionsContainer.appendChild(stopButton);
                            }
                        }
                    }
                };
                updateTime(); // Initial update
                countdownIntervals[index] = setInterval(updateTime, 1000); // Store interval ID
            } else {
                // For stopped events, just set the final time and don't update
                timeRemainingElem.textContent = getTimeRemaining(countdown.targetDate, countdown.stoppedAt);
            }
        }

        // Function to render all countdowns
        function renderCountdowns() {
            // Clear all active intervals before re-rendering
            for (const key in countdownIntervals) {
                clearInterval(countdownIntervals[key]);
                delete countdownIntervals[key];
            }

            countdownsContainer.innerHTML = ''; // Clear existing countdowns
            if (countdowns.length === 0) {
                noCountdownsMessage.classList.remove('hidden');
            } else {
                noCountdownsMessage.classList.add('hidden');
                countdowns.forEach((countdown, index) => {
                    renderCountdownCard(countdown, index);
                });
            }
        }

        // Function to remove a countdown
        function removeCountdown(indexToRemove) {
            // Clear the interval associated with the removed countdown
            if (countdownIntervals[indexToRemove]) {
                clearInterval(countdownIntervals[indexToRemove]);
                delete countdownIntervals[indexToRemove];
            }

            countdowns = countdowns.filter((_, index) => index !== indexToRemove);
            updateUrl();
            renderCountdowns(); // Re-render all to adjust indices and intervals
        }

        // Function to stop a countdown
        function stopCountdown(indexToStop) {
            if (countdowns[indexToStop]) {
                countdowns[indexToStop].stoppedAt = new Date().toISOString(); // Record stop time
                updateUrl();
                renderCountdowns(); // Re-render to update the display and clear interval
            }
        }

        // Event listener for adding a new countdown
        addCountdownButton.addEventListener('click', () => {
            const description = descriptionInput.value.trim();
            const targetDateStr = targetDateInput.value;

            // Validate inputs
            if (!description || !targetDateStr) {
                errorMessage.textContent = 'Please fill in both description and target date.';
                errorMessage.classList.remove('hidden');
                return;
            }

            // Parse YYYY-MM-DD string into year, month, day
            const targetDateParts = targetDateStr.split('-').map(Number);
            // Create a Date object for local midnight (00:00:00) on the target date.
            // Month is 0-indexed in Date constructor (e.g., August is 7, not 8).
            const targetDateTime = new Date(targetDateParts[0], targetDateParts[1] - 1, targetDateParts[2], 0, 0, 0);

            if (isNaN(targetDateTime.getTime())) { // Check for invalid date
                errorMessage.textContent = 'Invalid date format. Please use the date picker.';
                errorMessage.classList.remove('hidden');
                return;
            }

            errorMessage.classList.add('hidden'); // Hide error message on success

            // Add new countdown
            // Initialize 'stoppedAt' as null for new countdowns
            countdowns.push({ description: description, targetDate: targetDateTime.toISOString(), stoppedAt: null });
            descriptionInput.value = ''; // Clear input
            targetDateInput.value = ''; // Clear input

            updateUrl();
            renderCountdowns();
        });

        // Initialize on page load: check URL for existing countdowns
        window.onload = function () {
            const urlParams = new URLSearchParams(window.location.search);
            const encodedData = urlParams.get('data');

            if (encodedData) {
                const decodedData = decodeCountdowns(encodedData);
                if (Array.isArray(decodedData)) {
                    // Ensure 'stoppedAt' property exists for older saved countdowns
                    countdowns = decodedData.map(c => ({
                        description: c.description,
                        targetDate: c.targetDate,
                        stoppedAt: c.stoppedAt || null // Default to null if undefined
                    }));
                }
            }

            renderCountdowns();
        };
    </script>
</body>

</html>
