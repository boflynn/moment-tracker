<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moment Tracker</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles can go here if needed, but Tailwind is preferred */
        body {
            font-family: 'Inter', sans-serif;
            /* Using Inter font as per instructions */
            background-color: #f3f4f6;
            /* Light gray background */
        }

        .countdown-card {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s ease-in-out;
        }

        .countdown-card:hover {
            transform: translateY(-5px);
        }
    </style>
</head>

<body class="bg-gray-100 min-h-screen flex flex-col items-center py-8 px-4 sm:px-6 lg:px-8">
    <div class="max-w-4xl w-full bg-white p-6 sm:p-8 rounded-lg shadow-xl border border-gray-200">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-center text-gray-900 mb-8 leading-tight">
            Moment Tracker
        </h1>

        <!-- Add New Countdown Section -->
        <div class="mb-10 p-6 bg-blue-50 rounded-lg border border-blue-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-5 text-center">Add a New Moment</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div class="md:col-span-1">
                    <label for="description" class="block text-sm font-medium text-gray-700 mb-1">Description</label>
                    <input type="text" id="description" placeholder="e.g., Christmas, Vacation, Project Deadline"
                        class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm transition duration-150 ease-in-out" />
                </div>
                <div class="md:col-span-1">
                    <label for="targetDate" class="block text-sm font-medium text-gray-700 mb-1">Target Date</label>
                    <!-- Input type changed to 'date' for selecting only date -->
                    <input type="date" id="targetDate"
                        class="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 shadow-sm transition duration-150 ease-in-out" />
                </div>
                <div class="md:col-span-1 flex items-end">
                    <button id="addCountdown"
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-150 ease-in-out transform hover:scale-105">
                        Add Countdown
                    </button>
                </div>
            </div>
            <p id="errorMessage" class="text-red-600 text-sm mt-2 hidden text-center"></p>
        </div>

        <!-- Countdown List Section -->
        <div id="countdownsContainer" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- Countdown cards will be rendered here by JavaScript -->
            <p id="noCountdownsMessage" class="col-span-full text-center text-gray-500 text-lg hidden">
                No countdowns added yet. Add one above!
            </p>
        </div>
    </div>

    <script>
        // Set a default font family for the entire document as recommended.
        document.documentElement.style.fontFamily = "'Inter', sans-serif";

        // Array to store countdown objects
        let countdowns = [];

        // Get DOM elements
        const descriptionInput = document.getElementById('description');
        const targetDateInput = document.getElementById('targetDate');
        const addCountdownButton = document.getElementById('addCountdown');
        const countdownsContainer = document.getElementById('countdownsContainer');
        const errorMessage = document.getElementById('errorMessage');
        const noCountdownsMessage = document.getElementById('noCountdownsMessage');

        /**
         * Encodes the countdowns array into a URL-friendly Base64 string.
         * The process is: JSON.stringify -> btoa (Base64) -> encodeURIComponent.
         * @param {Array<Object>} data The array of countdown objects.
         * @returns {string} The encoded string.
         */
        function encodeCountdowns(data) {
            try {
                const jsonString = JSON.stringify(data);
                const base64String = btoa(jsonString); // Encode to Base64
                return encodeURIComponent(base64String); // Encode for URL safety
            } catch (e) {
                console.error("Error encoding countdowns:", e);
                return '';
            }
        }

        /**
         * Decodes the URL-friendly Base64 string back into the countdowns array.
         * The process is: decodeURIComponent -> atob (Base64 decode) -> JSON.parse.
         * @param {string} encodedString The encoded string from the URL.
         * @returns {Array<Object>} The decoded array of countdown objects, or an empty array on error.
         */
        function decodeCountdowns(encodedString) {
            try {
                const decodedUriComponent = decodeURIComponent(encodedString); // Decode URL component
                const decodedBase64 = atob(decodedUriComponent); // Decode from Base64
                return JSON.parse(decodedBase64); // Parse JSON string
            } catch (e) {
                console.error("Error decoding countdowns:", e);
                return []; // Return empty array on error
            }
        }

        // Function to update the URL with the current countdowns data
        function updateUrl() {
            const encodedData = encodeCountdowns(countdowns);
            // Use replaceState to avoid adding multiple history entries for small changes
            window.history.replaceState(null, '', `?data=${encodedData}`);
        }

        /**
         * Calculates and formats the time remaining until or since the target date.
         * Displays as "Xd Yh Zm As" or "Xd Yh Zm As ago".
         * @param {string} targetDate The target date string (ISO format).
         * @returns {string} The formatted time string.
         */
        function getTimeRemaining(targetDate) {
            const now = new Date().getTime();
            const targetTime = new Date(targetDate).getTime();
            let distance = targetTime - now;
            let suffix = '';

            if (distance < 0) {
                suffix = ' ago'; // Add 'ago' for past dates
                distance = Math.abs(distance); // Use absolute distance for calculations
            } else if (distance === 0) {
                return "Just now!";
            }


            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);

            // Build the string dynamically, omitting parts that are zero if larger units are zero
            let timeString = '';
            if (days > 0) timeString += `${days}d `;
            if (days > 0 || hours > 0) timeString += `${hours}h `;
            if (days > 0 || hours > 0 || minutes > 0) timeString += `${minutes}m `;
            timeString += `${seconds}s`; // Seconds always shown

            return timeString.trim() + suffix; // Add suffix at the end
        }

        // Function to render a single countdown card
        function renderCountdownCard(countdown, index) {
            const card = document.createElement('div');
            card.id = `countdown-${index}`; // Assign a unique ID for updates
            card.className = 'countdown-card bg-white p-5 rounded-lg border border-gray-200 flex flex-col justify-between';

            const descriptionElem = document.createElement('h3');
            descriptionElem.className = 'text-xl font-semibold text-gray-800 mb-3';
            descriptionElem.textContent = countdown.description;

            const dateElem = document.createElement('p');
            dateElem.className = 'text-sm text-gray-500 mb-4';
            // Changed to toLocaleDateString() to exclude the time part
            dateElem.textContent = `Target: ${new Date(countdown.targetDate).toLocaleDateString()}`;

            const timeRemainingElem = document.createElement('p');
            timeRemainingElem.className = 'text-3xl font-bold text-blue-600 mb-4'; // Bigger text for time remaining

            const removeButton = document.createElement('button');
            removeButton.className = 'bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out self-end mt-auto';
            removeButton.textContent = 'Remove';
            removeButton.onclick = () => removeCountdown(index);

            card.append(descriptionElem, dateElem, timeRemainingElem, removeButton);
            countdownsContainer.appendChild(card);

            // Update time remaining every second
            const updateTime = () => {
                const timeStr = getTimeRemaining(countdown.targetDate);
                timeRemainingElem.textContent = timeStr;
                // Dynamically change text color based on past/future
                if (timeStr.includes('ago')) {
                    timeRemainingElem.classList.remove('text-blue-600');
                    timeRemainingElem.classList.add('text-gray-500'); // Gray for past events
                } else {
                    timeRemainingElem.classList.remove('text-gray-500');
                    timeRemainingElem.classList.add('text-blue-600'); // Blue for future events
                }
            };
            updateTime(); // Initial update
            setInterval(updateTime, 1000); // Update every second
        }

        // Function to render all countdowns
        function renderCountdowns() {
            countdownsContainer.innerHTML = ''; // Clear existing countdowns
            if (countdowns.length === 0) {
                noCountdownsMessage.classList.remove('hidden');
            } else {
                noCountdownsMessage.classList.add('hidden');
                countdowns.forEach((countdown, index) => {
                    renderCountdownCard(countdown, index);
                });
            }
        }

        // Function to remove a countdown
        function removeCountdown(indexToRemove) {
            countdowns = countdowns.filter((_, index) => index !== indexToRemove);
            updateUrl();
            renderCountdowns();
        }

        // Event listener for adding a new countdown
        addCountdownButton.addEventListener('click', () => {
            const description = descriptionInput.value.trim();
            const targetDateStr = targetDateInput.value;

            // Validate inputs
            if (!description || !targetDateStr) {
                errorMessage.textContent = 'Please fill in both description and target date.';
                errorMessage.classList.remove('hidden');
                return;
            }

            // Parse YYYY-MM-DD string into year, month, day
            const targetDateParts = targetDateStr.split('-').map(Number);
            // Create a Date object for local midnight (00:00:00) on the target date.
            // Month is 0-indexed in Date constructor (e.g., August is 7, not 8).
            const targetDateTime = new Date(targetDateParts[0], targetDateParts[1] - 1, targetDateParts[2], 0, 0, 0);

            if (isNaN(targetDateTime.getTime())) { // Check for invalid date
                errorMessage.textContent = 'Invalid date format. Please use the date picker.';
                errorMessage.classList.remove('hidden');
                return;
            }

            errorMessage.classList.add('hidden'); // Hide error message on success

            // Add new countdown
            // Store as ISO string (which will convert local midnight to its UTC equivalent).
            // When re-parsed and displayed with toLocaleString(), it will revert to local time.
            countdowns.push({ description: description, targetDate: targetDateTime.toISOString() });
            descriptionInput.value = ''; // Clear input
            targetDateInput.value = ''; // Clear input

            updateUrl();
            renderCountdowns();
        });

        // Initialize on page load: check URL for existing countdowns
        window.onload = function () {
            const urlParams = new URLSearchParams(window.location.search);
            const encodedData = urlParams.get('data');

            if (encodedData) {
                const decodedData = decodeCountdowns(encodedData);
                if (Array.isArray(decodedData)) {
                    countdowns = decodedData;
                }
            }

            renderCountdowns();
        };
    </script>
</body>

</html>
